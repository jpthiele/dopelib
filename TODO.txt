TODO DOpE
=========

Treffen (Sep 19, 2012)
- FoD
  Zukunft (evtl. Oeffnung zu DUNE)
  Entwicklertreffen (Anfang 2013: Ort?? Potschka)
  svn mirror vor Dez 2013 (Bauarbeiten URZ)
  Oeffentlicher Download (erstmal Doku und funktionstuechtige Software)
  DOpE Einfuehrung (wir sind alle dafuer, Winni faengt an)
  Mailingliste (dopedev@ganymed ... )
  Hosting (DOpElib domain kaufen!)
  Maintainer (in Jahreszahlen -> macht Winni)
  License 
  svn general (erstmal Heidelberg lassen, wenn Winni Dauerstelle, dann umziehen)
	
- Paper






- Paper
  x Aufbau
	I. Introduction --> 1st draft von Winni 
	II. Aufbau der Bib (Anhand einfacher Beispiele, was muesste User tun?)
	  II.1. PDE
		II.1.a. stationaer
		II.1.b. instationaer --> 1st draft Thomas
	  II.2. OPT
	  II.3. Misc (DWR (Christian), Residualestimator, Multimesh, ...)
	III. Beispiele (kurz, nicht quantitativ, eher schoene Bilder, )
	  III.1. NS mit DWR (Drag, Lift, Punktauswertung?) --> cgoll 
	  III.2. FSI --> Thomas
	  III.3. Comp. - Minimization --> Winni
 
	  

- The residual-based error estimators (i.e. H1 and L2) do not work with vector-valued solutions. 
  First lines one should look at is (revision 208):      DOpEsrc/container/residualestimator.h:397 and 207
              VectorTools::interpolate(*(static_cast<const DOFHANDLER*>(dofh)),
                ConstantFunction<dim>(1.), vals);
  
- Rewrite documentation of PDE/InstatPDE/Example1. The equation is navier stokes, not stokes.

- Wie aktualisiere ich die Homepage? ./copywebsite.sh funktioniert nicht
  so richtig (keine Verbindung nach Hamburg)
- Usertreffen am 20.,21. Sep 2012 in HD??
- Mailingliste: 
  Vorschlag TW: dope@ganymed... und dope-dev@ganymed
  wir haben nun einige neue Mitglieder: wer soll E-Mails
  bekommen und wer nicht.
- Funktionalauswertung in Opt-Problemen abhängig vom Typ machen: zur 
  Zeit werden die Ableitungen der Funktionale (sobald diese 
  in localfunctional.cc implementiert sind) IMMER ausgewertet.

- Newtonlöser: last_newton_solution (in Matrix?!) ändern. 

- Recheck args in TS-Schemes, i.e., not always are scale and scale ico used 
  consistenly in Equation, BoundaryEquation ...

- Common Codeschnipsel in den STH in eigener Klasse zusammenfuehren. Das gleiche fuer die problemcontainer.

- Alle Functional Calls in opt-problem-container sollten vor dem 
  Aufruf prüfen ob die ,,Zeit (time)'' auch benötigt wird (NeedTime)

- Need to differentiate in functional between terms that are integrals in time 
  and those that are not! Needed for derivatives only.

- Beim naechsten Treffen: Am ersten Tag wird der Code von vorne bis hinten
einheitlich (!) kommentiert.

- Einheitliche Handhabung ob etwas pointer oder Reference wird...

- Adjungierte Zeitschrittverfahren 
  (Dann geht endlich auch Opt-Control im Instationaeren), sind noch
  fertigzustellen.

- Verschiedene Kontrolltypen im Instationaeren, insbesondere Kontrolle in den AWen
-- Verschiedene Typen der Kontrolle (undefined, initial, timedistributed, timedistributedtimedependend). Diese gibt man dem Kontrollvektor, der den Typ wiederum an STH lieftert. Dieser speichert ihn und stellt sicher, dass alle Kontrollen den selben Typen haben. ~cg

- SetType im Optproblem sollte auch dem Funktional den typ mitteilen.

- Beispiel (Erklaerung), PDEInterface nicht als template geben, sondern die LocalPDE.

- Webseite: 
  -- domain
  -- wie komme ich an DOpE?? Mail an dopelib@...
  -- How to cite...

- PeriodicDoFConstraintMaker in Lib

- FE_Values ? Kann man dim=0 anlegen? Dann kann der weg (Ja, habs auskommentiert,
  trotzdem laeufen alle Probleme korrekt durch (ausser OPT/7+8))~tw

- Remove unnecessary Template Parameter
  -- integrator.h: dim

- Beispiele besser Kommentieren.

- Prm-File Number-Precision sollte einfluss auf Funktionalausgabe haben, z.B., lift in PDE/InstatPDE[12]

- hp Beispiel in PDE/StatPDE/Example1 ~cg !!!!
	
- Fehlerschaetzer 
  (zumindest fuer stationaere Probleme)
  Aenderungen:
  - stat[reduced|pde]problem.h
	-- Neuer Problemtyp 'dual_for_estimate' in the various stat[pde|reduced]problems. 
	   ALTERNATIVE: Eigenes Problem?
	-- Loeser fuer das duale Problem? Welchen da nehmen?
	-- Membervariable _u_dual ? So kommen wir nicht mit _z ins Gehege.
	-- ComputeDualForErrorEstimation() als private Memberfunction
	-- ComputeErrorIndicators()
	-- DWRDataContainer hinzufuegen (soll higher order elements und dofhandler etc. verwalten)?
	-- Welchen Nonlinearsolver benutzen? Einen eigenen hinzufuegen?
	
  - pdeinterface.h
	-- (done) Starke Formulierung -> Strong[Cell|Face|Boundary]Equation und Strong[Cell|Face|Boundary]Equation_U.
	-- (done) (Wir benoetigen hier auch in den FaceDataContainern auch einen Zugriff auf die FEValues der Nachbarzelle.
	  Fuer den hp-Fall ist das schon implementiert, kann man dann so auch fuer die Normalen FaceDataContainer 
	  implementieren.)
	  Weitere Frage hier: um a(u_h, PI_h z_h) zu berechnen: Sei u_h Q1-Funktion, dann ist PI_h z_h Q2 Funktion. Wollen wir 
	  dafuer 2 CellDataContainer, die z.B. an StrongCellEquation gehen, oder erweitern wir den Vorhandenen? Ich waere dafuer, den
	  vorhandenen zu erweitern, wie wir das bisher immer gemacht haben (z.B. mit multimesh).
  - (done) facedatacontainer.h
	-- s.o. dem 'normalen' FaceDataContainer ermoeglichen, auf Nachbarelemente zuzugreifen (wegen Kantenspruengen.)
  - optproblem.h/PDEProblemContainer.h
	-- (done) AddDualFunctional. Irgendwie muss das Zielfunktional bestimmt werden.
	Winni haette gerne eine Auswahl aus den Aux_Funktionalen, daher: Identifikation ueber Namen.
  - integrator.h
	-- Routine zum auswerten der Fehlerindikatoren.
  - Ungeklaert ist noch, wie genau die higher order FE, DoFHandler etc. gehandelt werden.(Abgeleitete Klassen der DoFHandler, oder eigenstaendige Klasse, die dem DoFhandler lediglich uebergeben wird?)	
	
- Interpretation der primalen Zeitschrittverfahren als Galerkin-Verfahren.
	-- Klasse schreiben (short-statevector o.ae.), die im instationaeren Fall dem
	Newtonsolver lediglich die fuer das aktuelle Zeitintervall noetigen Freiheitsgrade
	uebergibt. Friend oder abgeleitet vom Statevector, im Konstruktor aktuelles Zeitintervall plus STH, generiert dann Liste von Zeitpunkten, auf denen er arbeitet.~tw
	-- Zeitintegrator ~cg

- (homogene!) Dirichletdaten ueber Constraintmatrix lokal.

- Erzeugen von Subproblemen fuer Primales, Duales, ... Problem, anstatt alles im Optproblem zu unterscheiden
optproblem, davon abgeleitet forwardproblem und backwardproblem (mit Matrix),
davon state und tangent bzw. dual und dual hessian ~ww
  
- Trennung der Ortsdiskretisierung (verschieden Feine Gitter) 
  --Integrals on faces/boundaries                                                                                  
                (Upgrades for integrator_multimesh and multimesh_facedatacontainer needed)                           
  --Support for nonstationary problems                                                                             
                (Upgrades for integrator_multimesh needed)                                                           

- Standardinterface fuer Postprozesse? 
	-- Basisklasse fuer Postprozesse
	-- Liste von Postprozessbasisklassen in Reduced Problem.
	-- Aufruf von ausserhalb: do postprocess!!!11! 
	
- Flag, um exception im Newton zu ignorieren.
- ForceComputationFlag fuer ControlNewton, reicht das weiter an den StateNewton.

- Make some automated memchecks, e.g., valgrind --tool=memcheck --leak-check=full --error-exitcode=1 [Programmname] 
  will return 0 if no errors but a nonzero exitcode if there are some errors...

-  Rueckgabeklasse fuer Newton. 
-  Loesen des Opt-Control Probleme ueber die KKT-Bedingungen 
  (im stationaeren, benötigt Matrizen für die gemischten Ableitungen, wollen wir dazu neue 
  Terme haben, oder wollen wir alle linearen Teile über Matrizen bauen?)
  -- Newtonsolver zu aendern (ueberpruefen, ob kostenfunktional kleiner wird)
  -- BlockMatrix fuer das KKT-System. -> Eigenen Integrator schreiben.


