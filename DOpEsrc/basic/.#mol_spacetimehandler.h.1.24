#ifndef _MOL_SPACE_TIME_HANDLER_H_
#define _MOL_SPACE_TIME_HANDLER_H_

#include "spacetimehandler.h"
#include "dofhandler_wrapper.h"
#include "constraints.h"
#include "sparsitymaker.h"
#include "constraintsmaker.h"

#include <dofs/dof_handler.h>
#include <dofs/dof_renumbering.h>
#include <dofs/dof_tools.h>
#include <lac/constraint_matrix.h>
#include <deal.II/numerics/solution_transfer.h>
#include <deal.II/grid/grid_refinement.h>

namespace DOpE
{
  /**
   * Implements a Space Time Handler with a Method of Lines discretization.
   * This means there is only one fixed mesh for the spatial domain.
   */
  template<typename FE, typename DOFHANDLER, typename SPARSITYPATTERN,
      typename VECTOR, typename SPARSITYMAKER, typename CONSTRAINTSMAKER,
      int dopedim, int dealdim>
    class MethodOfLines_SpaceTimeHandler : public SpaceTimeHandler<FE,
        DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim, dealdim>
    {
    public:
      MethodOfLines_SpaceTimeHandler(
          dealii::Triangulation<dealdim>& triangulation,
          const FE& control_fe,
          const FE& state_fe,
          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
            SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim,
                dealdim> ( index_setter), _triangulation(triangulation),
            _control_dof_handler(_triangulation),
            _state_dof_handler(_triangulation), _control_fe(&control_fe),
            _state_fe(&state_fe), _constraints(), _control_mesh_transfer(NULL),
            _sparse_mkr_dynamic(true), _constr_mkr_dynamic(true)
      {
        //#if dope_dimension == deal_II_dimension
        //        _control_dof_handler = new DOpEWrapper::DoFHandler<dopedim>(
        //            triangulation);
        //#elif dope_dimension == 0
        //        _control_dof_handler = new DOpEWrapper::DoFHandler<dopedim>();
        //#endif
        _sparsitymaker = new SPARSITYMAKER;
        _constraintsmaker = new CONSTRAINTSMAKER;
      }
      MethodOfLines_SpaceTimeHandler(
          dealii::Triangulation<dealdim>& triangulation,
          const FE& control_fe,
          const FE& state_fe,
          const dealii::Triangulation<1> & times,
          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
            SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim,
                dealdim> (times, index_setter), _triangulation(triangulation),
            _control_dof_handler(_triangulation),
            _state_dof_handler(_triangulation), _control_fe(&control_fe),
            _state_fe(&state_fe), _constraints(), _control_mesh_transfer(NULL),
            _sparse_mkr_dynamic(true), _constr_mkr_dynamic(true)
      {
        //#if dope_dimension == deal_II_dimension
        //        _control_dof_handler = new DOpEWrapper::DoFHandler<dopedim>(
        //            triangulation);
        //#elif dope_dimension == 0
        //        _control_dof_handler = new DOpEWrapper::DoFHandler<dopedim>();
        //#endif
        _sparsitymaker = new SPARSITYMAKER;
        _constraintsmaker = new CONSTRAINTSMAKER;
      }

      MethodOfLines_SpaceTimeHandler(
          dealii::Triangulation<dealdim>& triangulation,
          const FE& control_fe,
          const FE& state_fe,
          const Constraints& c,
          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
            SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim,
                dealdim> (index_setter), _triangulation(triangulation),
            _control_dof_handler(_triangulation),
            _state_dof_handler(_triangulation), _control_fe(&control_fe),
            _state_fe(&state_fe), _constraints(c),
            _control_mesh_transfer(NULL), _sparse_mkr_dynamic(true),
            _constr_mkr_dynamic(true)
      {
        _sparsitymaker = new SPARSITYMAKER;
        _constraintsmaker = new CONSTRAINTSMAKER;
      }

      MethodOfLines_SpaceTimeHandler(
          dealii::Triangulation<dealdim>& triangulation,
          const FE& control_fe,
          const FE& state_fe,
          const dealii::Triangulation<1> & times,
          const Constraints& c,
          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
            SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim,
                dealdim> (times, index_setter), _triangulation(triangulation),
            _control_dof_handler(_triangulation),
            _state_dof_handler(_triangulation), _control_fe(&control_fe),
            _state_fe(&state_fe), _constraints(c),
            _control_mesh_transfer(NULL), _sparse_mkr_dynamic(true),
            _constr_mkr_dynamic(true)
      {
        _sparsitymaker = new SPARSITYMAKER;
        _constraintsmaker = new CONSTRAINTSMAKER;
      }

      //      MethodOfLines_SpaceTimeHandler(
      //          dealii::Triangulation<dealdim>& triangulation,
      //          const DOpEWrapper::FECollection<dealdim>& control_fe,
      //          const DOpEWrapper::FECollection<dealdim>& state_fe,
      //          const std::vector<double>& times,
      //          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
      //              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
      //            SpaceTimeHandler<SPARSITYPATTERN, VECTOR, dopedim, dealdim> (times,
      //                index_setter, "hp"), _triangulation(triangulation),
      //            _control_dof_handler(NULL), _state_dof_handler(NULL),
      //            _control_hp_dof_handler(NULL), _state_hp_dof_handler(NULL),
      //            _control_fe(NULL), _state_fe(NULL),
      //            _control_fe_collection(&control_fe),
      //            _state_fe_collection(&state_fe), _constraints(),
      //            _control_mesh_transfer(NULL), _sparse_mkr_dynamic(true),
      //            _constr_mkr_dynamic(true)
      //      {
      //#if dope_dimension == deal_II_dimension
      //        _control_hp_dof_handler = new DOpEWrapper::HpDoFHandler<dopedim>(
      //            triangulation);
      //#elif dope_dimension == 0
      //#warning muss noch implementiert werden: es gibt keinen default-konstruktor fuer hp-dofhandler
      //#endif
      //        _state_hp_dof_handler = new DOpEWrapper::HpDoFHandler<dealdim>(
      //            triangulation);
      //        _sparsitymaker = new SPARSITYMAKER;
      //        _constraintsmaker = new CONSTRAINTSMAKER;
      //      }
      //
      //      MethodOfLines_SpaceTimeHandler(
      //          dealii::Triangulation<dealdim>& triangulation,
      //          const DOpEWrapper::FECollection<dealdim>& control_fe,
      //          const DOpEWrapper::FECollection<dealdim>& state_fe,
      //          const std::vector<double>& times,
      //          const Constraints& c,
      //          const ActiveFEIndexSetterInterface<dopedim, dealdim>& index_setter =
      //              ActiveFEIndexSetterInterface<dopedim, dealdim> ()) :
      //            SpaceTimeHandler<SPARSITYPATTERN, VECTOR, dopedim, dealdim> (times,
      //                index_setter, "hp"), _triangulation(triangulation),
      //            _control_dof_handler(NULL), _state_dof_handler(NULL),
      //            _control_hp_dof_handler(NULL), _state_hp_dof_handler(NULL),
      //            _control_fe(NULL), _state_fe(NULL),
      //            _control_fe_collection(&control_fe),
      //            _state_fe_collection(&state_fe), _constraints(c),
      //            _control_mesh_transfer(NULL), _sparse_mkr_dynamic(true),
      //            _constr_mkr_dynamic(true)
      //      {
      //#if dope_dimension == deal_II_dimension
      //        _control_hp_dof_handler = new DOpEWrapper::HpDoFHandler<dopedim>(
      //            triangulation);
      //#elif dope_dimension == 0
      //        //FIXME muss noch implementiert werden: es gibt keinen default-konstruktor fuer hp-dofhandler
      //#endif
      //        _state_hp_dof_handler = new DOpEWrapper::HpDoFHandler<dealdim>(
      //            triangulation);
      //        _sparsitymaker = new SparsityMaker<dealdim> ();
      //        _constraintsmaker = new ConstraintsMaker<dealdim> ();
      //      }

      ~MethodOfLines_SpaceTimeHandler()
      {
        _control_dof_handler.clear();

        _state_dof_handler.clear();

        if (_control_mesh_transfer != NULL)
          {
            delete _control_mesh_transfer;
          }
        if (_sparsitymaker != NULL && _sparse_mkr_dynamic == true)
          {
            delete _sparsitymaker;
          }
        if (_constraintsmaker != NULL && _constr_mkr_dynamic == true)
          {
            delete _constraintsmaker;
          }
      }

      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      void
      ReInit(unsigned int control_n_blocks,
          const std::vector<unsigned int>& control_block_component,
          unsigned int state_n_blocks,
          const std::vector<unsigned int>& state_block_component)
      {
        //        if (this->GetDoFHandlerType() == "classic")
        //          {
#if dope_dimension > 0
        SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN,
        VECTOR, dopedim, dealdim>::SetActiveFEIndicesControl(_control_dof_handler);
#endif
        _control_dof_handler.distribute_dofs(*_control_fe);
#if dope_dimension > 0
        DoFRenumbering::component_wise (static_cast<DOFHANDLER&>(_control_dof_handler),
            control_block_component);
        if(dopedim==dealdim)
          {
            _control_hanging_node_constraints.clear ();
            DoFTools::make_hanging_node_constraints (static_cast<DOFHANDLER&>(_control_dof_handler),
                _control_hanging_node_constraints);
            _control_hanging_node_constraints.close ();
          }
        else
          {
            throw DOpEException("Not implemented for dopedim != dealdim","MethodOfLines_SpaceTimeHandler::ReInit");
          }
#endif
        _control_dofs_per_block.resize(control_n_blocks);
#if dope_dimension > 0
          {
            DoFTools::count_dofs_per_block (static_cast<DOFHANDLER&>(_control_dof_handler),
                _control_dofs_per_block,control_block_component);
          }
#else
          {
            for (unsigned int i = 0; i < _control_dofs_per_block.size(); i++)
              {
                _control_dofs_per_block[i] = 0;
              }
            for (unsigned int i = 0; i < control_block_component.size(); i++)
              {
                _control_dofs_per_block[control_block_component[i]]++;
              }
          }
#endif
        SpaceTimeHandler<FE, DOFHANDLER, SPARSITYPATTERN, VECTOR, dopedim,
            dealdim>::SetActiveFEIndicesState(_state_dof_handler);
        _state_dof_handler.distribute_dofs(*GetFESystem("state"));
        DoFRenumbering::component_wise(
            static_cast<DOFHANDLER&> (_state_dof_handler),
            state_block_component);

        GetConstraintsMaker()->MakeConstraints(_state_dof_handler,
            _state_hanging_node_constraints);

        _state_dofs_per_block.resize(state_n_blocks);
        DoFTools::count_dofs_per_block(
            static_cast<DOFHANDLER&> (_state_dof_handler),
            _state_dofs_per_block, state_block_component);

        _support_points.clear();

        _constraints.ReInit(_control_dofs_per_block, _state_dofs_per_block);
        //          }
        //        else
        //          {
        //            if (this->GetDoFHandlerType() == "hp")
        //              {
        //#if dope_dimension > 0
        //                this->SetActiveFEIndicesControl(*_control_hp_dof_handler);
        //#endif
        //                _control_hp_dof_handler->distribute_dofs(
        //                    *GetFECollection("control"));
        //
        //#if dope_dimension > 0
        //                DoFRenumbering::component_wise (static_cast<dealii::hp::DoFHandler<dopedim>&>(*_control_hp_dof_handler),
        //                    control_block_component);
        //                if(dopedim==dealdim)
        //                  {
        //                    _control_hanging_node_constraints.clear ();
        //                    DoFTools::make_hanging_node_constraints (static_cast<dealii::hp::DoFHandler<dopedim>&>(*_control_hp_dof_handler),
        //                        _control_hanging_node_constraints);
        //                    _control_hanging_node_constraints.close ();
        //                  }
        //                else
        //                  {
        //                    throw DOpEException("Not implemented for dopedim != dealdim","MethodOfLines_SpaceTimeHandler::ReInit");
        //                  }
        //#endif
        //                _control_dofs_per_block.resize(control_n_blocks);
        //#if dope_dimension > 0
        //                  {
        //#warning laeuft eventuell nicht fuer hp...waere dann zu implementieren
        //                    //	DoFTools::count_dofs_per_block (static_cast<dealii::hp::DoFHandler<dopedim>&>(*_control_hp_dof_handler),
        //                    //						_control_dofs_per_block,control_block_component);
        //                    if(_control_dofs_per_block.size()==1)
        //                      {
        //                        _control_dofs_per_block.at(0)=_control_hp_dof_handler->n_dofs();
        //                      }
        //                    else
        //                      {
        //                        throw DOpEException("Not implemented for more than one block in the hp-case.", "MethodOfLines_SpaceTimeHandler::ReInit");
        //                      }
        //                  }
        //#else
        //                  {
        //                    for (unsigned int i = 0; i < _control_dofs_per_block.size(); i++)
        //                      {
        //                        _control_dofs_per_block[i] = 0;
        //                      }
        //                    for (unsigned int i = 0; i < control_block_component.size(); i++)
        //                      {
        //                        _control_dofs_per_block[control_block_component[i]]++;
        //                      }
        //                  }
        //#endif
        //                this->SetActiveFEIndicesState(*_state_hp_dof_handler);
        //                _state_hp_dof_handler->distribute_dofs(
        //                    *GetFECollection("state"));
        //                DoFRenumbering::component_wise(
        //                    static_cast<dealii::hp::DoFHandler<dealdim>&> (*_state_hp_dof_handler),
        //                    state_block_component);
        //
        //                GetConstraintsMaker()->MakeConstraints(*_state_hp_dof_handler,
        //                    _state_hanging_node_constraints);
        //
        //                _state_dofs_per_block.clear();
        //                _state_dofs_per_block.resize(state_n_blocks);
        //
        //                //FIXME Funktioniert nur fur primitive FE. Eventuell muss ein deal udpate durchgefuehrt werden (DoFTools).
        //                std::vector<unsigned int> dofs_per_component(
        //                    state_block_component.size(), 0);
        //                DoFTools::count_dofs_per_component(
        //                    static_cast<dealii::hp::DoFHandler<dealdim>&> (*_state_hp_dof_handler),
        //                    dofs_per_component);
        //                for (unsigned int i = 0; i < dofs_per_component.size(); i++)
        //                  {
        //                    _state_dofs_per_block[state_block_component[i]]
        //                        += dofs_per_component[i];
        //                  }
        //
        //                _support_points.clear();
        //
        //                _constraints.ReInit(_control_dofs_per_block,
        //                    _state_dofs_per_block);
        //              }
        //            else
        //              throw DOpEException(
        //                  "Unknown DofHandlerType " + this->GetDoFHandlerType(),
        //                  "MethodOfLine_SpaceTimeHandler::ReInit");
        //          }
        //There where changes invalidate tickets
        this->IncrementTicket();
      }

      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const DOpEWrapper::DoFHandler<dopedim, DOFHANDLER>&
      GetControlDoFHandler() const
      {
        //There is only one mesh, hence always return this
        return _control_dof_handler;
      }
      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const DOpEWrapper::DoFHandler<dealdim, DOFHANDLER>&
      GetStateDoFHandler() const
      {
        //There is only one mesh, hence always return this
        return _state_dof_handler;
      }

      //      /**
      //       * Implementation of virtual function in SpaceTimeHandler
      //       */
      //      const DOpEWrapper::HpDoFHandler<dopedim>&
      //      GetControlHpDoFHandler() const
      //      {
      //        //There is only one mesh, hence always return this
      //        return *_control_hp_dof_handler;
      //      }
      //      /**
      //       * Implementation of virtual function in SpaceTimeHandler
      //       */
      //      const DOpEWrapper::HpDoFHandler<dealdim>&
      //      GetStateHpDoFHandler() const
      //      {
      //        //There is only one mesh, hence always return this
      //        return *_state_hp_dof_handler;
      //      }

      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      unsigned int
      GetControlDoFsPerBlock(unsigned int b, int /*time_point*/= -1) const
      {
        return _control_dofs_per_block[b];
      }
      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      unsigned int
	GetStateDoFsPerBlock(unsigned int b, int /*time_point*/ = -1) const
      {
        return _state_dofs_per_block[b];
      }
      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      unsigned int
      GetConstraintDoFsPerBlock(std::string name, unsigned int b) const
      {
        return (_constraints.GetDoFsPerBlock(name))[b];
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      const std::vector<unsigned int>&
      GetControlDoFsPerBlock() const
      {
        return _control_dofs_per_block;
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      const std::vector<unsigned int>&
      GetStateDoFsPerBlock(int /*time_point*/ = -1) const
      {
        return _state_dofs_per_block;
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      const std::vector<unsigned int>&
      GetConstraintDoFsPerBlock(std::string name) const
      {
        return _constraints.GetDoFsPerBlock(name);
      }
      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const dealii::ConstraintMatrix&
      GetControlHangingNodeConstraints() const
      {
        return _control_hanging_node_constraints;
      }
      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const dealii::ConstraintMatrix&
      GetStateHangingNodeConstraints() const
      {
        return _state_hanging_node_constraints;
      }

      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */

      virtual void
      InterpolateState(VECTOR& result, const std::vector<VECTOR*> & local_vectors,
          double t, const TimeIterator& it) const
      {
        assert(it.get_left()<=t);
        assert(it.get_right()>=t);
        if(local_vectors.size()!=2)
          throw DOpEException(
              "This function is currently not implemented for anything other than"
              " linear interpolation of 2 DoFs.",
              "MethodOfLine_SpaceTimeHandler::InterpolateState");

        double lambda_l=(it.get_right()-t)/it.get_k();
        double lambda_r=(t-it.get_left())/it.get_k();

        //Here we assume that the numbering of dofs goes from left to right!
        result = *local_vectors[0];

        result.sadd(lambda_l, lambda_r, *local_vectors[1]);
      }

      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      GetControlNDoFs() const
      {
        return GetControlDoFHandler().n_dofs();
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      GetStateNDoFs(int /*time_point*/= -1) const
      {
        return GetStateDoFHandler().n_dofs();
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      GetConstraintNDoFs(std::string name) const
      {
        return _constraints.n_dofs(name);
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      GetNGlobalConstraints() const
      {
        return _constraints.global_n_dofs();
      }
      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      GetNLocalConstraints() const
      {
        return _constraints.local_n_dofs();
      }

      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const std::vector<Point<dealdim> >&
      GetMapDoFToSupportPoints()
      {
        //        if (_support_points.size() == 0)
        //          {
        _support_points.resize(GetStateNDoFs());
        //TODO should get Mapping used for  the FE.
        MappingQ1 < dealdim > mapping;
        //            if (this->GetDoFHandlerType() == "classic")
        //FIXME wie sieht das hier mit hp::dofhandler aus? Eventuell muss
        DoFTools::map_dofs_to_support_points(mapping, GetStateDoFHandler(),
            _support_points);
        //            else
        //              {
        //                if (this->GetDoFHandlerType() == "hp")
        //                  {
        //                    //	DoFTools::map_dofs_to_support_points(mapping, GetStateHpDoFHandler(), _support_points);
        //                  }
        //                else
        //                  throw DOpEException(
        //                      "Unknown DofHandlerType " + this->GetDoFHandlerType(),
        //                      "MethodOfLine_SpaceTimeHandler::GetMapDoFToSupportPoints");
        //              }

        //          }
        return _support_points;
      }

      /******************************************************/
      void
      ComputeControlSparsityPattern(SPARSITYPATTERN & sparsity) const;

      /******************************************************/
      void
      ComputeStateSparsityPattern(SPARSITYPATTERN & sparsity) const
      {
        //        if (this->GetDoFHandlerType() == "classic")
        //          {
        this->GetSparsityMaker()->ComputeSparsityPattern(
            this->GetStateDoFHandler(), sparsity,
            this->GetStateHangingNodeConstraints(),
            this->GetStateDoFsPerBlock());
        //          }
        //        else
        //          {
        //            if (this->GetDoFHandlerType() == "hp")
        //              {
        //                this->GetSparsityMaker()->ComputeSparsityPattern(
        //                    this->GetStateHpDoFHandler(), sparsity,
        //                    this->GetStateHangingNodeConstraints(),
        //                    this->GetStateDoFsPerBlock());
        //              }
        //            else
        //              throw DOpEException(
        //                  "Unknown DofHandlerType " + this->GetDoFHandlerType(),
        //                  "MethodOfLine_SpaceTimeHandler::ComputeStateSparsityPattern");
        //          }
      }

      /******************************************************/

      /**
       * Implementation of virtual function in SpaceTimeHandler
       */
      const dealii::SmartPointer<const FE>
      GetFESystem(std::string name) const
      {
        if (name == "state")
          {
            return _state_fe;
          }
        else if (name == "control")
          {
            return _control_fe;
          }
        else
          {
            throw DOpEException("Not implemented for name =" + name,
                "MethodOfLines_SpaceTimeHandler::GetFESystem");
          }

      }

      /******************************************************/

      //      /**
      //       * Implementation of virtual function in SpaceTimeHandler
      //       */
      //      const dealii::SmartPointer<const FE >
      //      GetFECollection(std::string name) const
      //      {
      //        if (name == "state")
      //          {
      //            return _state_fe_collection;
      //          }
      //        else if (name == "control")
      //          {
      //            if (dopedim == dealdim)
      //              {
      //                return _control_fe_collection;
      //              }
      //            else
      //              {
      //                throw DOpEException(
      //                    "Not implemented in the case dopedim != dealdim",
      //                    "MethodOfLines_SpaceTimeHandler::GetFECollection");
      //              }
      //          }
      //        else
      //          {
      //            throw DOpEException("Not implemented for name =" + name,
      //                "MethodOfLines_SpaceTimeHandler::GetFECollection");
      //          }
      //
      //      }

      /******************************************************/

      /**
       * This Function is used to refine the spatial mesh.
       * After calling a refinement function a reinitialization is required!
       *
       * @param ref_type          A string telling how to refine, feasible values are at present
       *                          'global', 'fixedfraction', 'fixednumber', 'optimized'
       * @param indicators        A set of positive values, used to guide refinement.
       * @param topfraction       In a fixed fraction strategy, wich part should be refined
       * @param bottomfraction    In a fixed fraction strategy, wich part should be coarsened
       */
      void
      RefineSpace(std::string ref_type, const Vector<float>* indicators = NULL,
          double topfraction = 0.1, double bottomfraction = 0.0)
      {
        assert(bottomfraction == 0.0);

        if (_control_mesh_transfer != NULL)
          {
            delete _control_mesh_transfer;
            _control_mesh_transfer = NULL;
          }
#if dope_dimension == deal_II_dimension
        _control_mesh_transfer = new dealii::SolutionTransfer<dopedim, VECTOR>(
            _control_dof_handler);
#endif
        if ("global" == ref_type)
          {
            _triangulation.set_all_refine_flags();
          }
        else if ("fixednumber" == ref_type)
          {
            assert(indicators != NULL);
            GridRefinement::refine_and_coarsen_fixed_number(_triangulation,
                *indicators, topfraction, bottomfraction);
          }
        else if ("fixedfraction" == ref_type)
          {
            assert(indicators != NULL);
            GridRefinement::refine_and_coarsen_fixed_fraction(_triangulation,
                *indicators, topfraction, bottomfraction);
          }
        else if ("optimized" == ref_type)
          {
            assert(indicators != NULL);
            GridRefinement::refine_and_coarsen_optimize(_triangulation,
                *indicators);
	    //TODO: how can we prevent coarsening here ?
          }
        else
          {
            throw DOpEException("Not implemented for name =" + ref_type,
                "MethodOfLines_SpaceTimeHandler::RefineSpace");
          }
        _triangulation.prepare_coarsening_and_refinement();

	//FIXME: works only if no coarsening happens, because we do not have the vectors to be interpolated availiable...
        if (_control_mesh_transfer != NULL)
          _control_mesh_transfer->prepare_for_pure_refinement();

        _triangulation.execute_coarsening_and_refinement();
      }
      /******************************************************/

      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      unsigned int
      NewTimePointToOldTimePoint(unsigned int t) const
      {
        //TODO this has to be implemented when temporal refinement is possible!
        //At present the temporal grid can't be refined
        return t;
      }

      /******************************************************/

      /**
       * Implementation of virtual function in SpaceTimeHandlerBase
       */
      void
      SpatialMeshTransferControl(const VECTOR& old_values, VECTOR& new_values) const
      {
        if (_control_mesh_transfer != NULL)
          _control_mesh_transfer->refine_interpolate(old_values, new_values);
      }
      /******************************************************/
      /**
       * Through this function one commits a constraints_maker
       * to the class. With the help of the constraints_maker
       * one has the capability to  impose additional constraints
       * on the state-dofs (for example a pressure filter for the
       * stokes problem). This function must be called prior to
       * ReInit.
       */
      void
      SetConstraintsMaker(CONSTRAINTSMAKER& constraints_maker)
      {
        if (_constraintsmaker != NULL && _constr_mkr_dynamic)
          delete _constraintsmaker;
        _constraintsmaker = &constraints_maker;
        _constr_mkr_dynamic = false;
      }
      /******************************************************/
      /**
       * Through this function one commits a sparsity_maker
       * to the class. With the help of the sparsity_maker
       * one has the capability to create non-standard sparsity
       * patterns. This function must be called prior to
       * ReInit.
       */
      void
      SetSparsityMaker(SPARSITYMAKER& sparsity_maker)
      {
        if (_sparsitymaker != NULL && _sparse_mkr_dynamic)
          delete _sparsitymaker;
        _sparsitymaker = &sparsity_maker;
        _sparse_mkr_dynamic = false;
      }

    private:
      const SPARSITYMAKER*
      GetSparsityMaker() const
      {
        return _sparsitymaker;
      }
      const CONSTRAINTSMAKER*
      GetConstraintsMaker() const
      {
        return _constraintsmaker;
      }
      SPARSITYMAKER* _sparsitymaker;
      CONSTRAINTSMAKER* _constraintsmaker;

      dealii::Triangulation<dealdim>& _triangulation;
      DOpEWrapper::DoFHandler<dopedim, DOFHANDLER> _control_dof_handler;
      DOpEWrapper::DoFHandler<dealdim, DOFHANDLER> _state_dof_handler;
      //      DOpEWrapper::HpDoFHandler<dopedim>* _control_hp_dof_handler;
      //      DOpEWrapper::HpDoFHandler<dealdim>* _state_hp_dof_handler;

      std::vector<unsigned int> _control_dofs_per_block;
      std::vector<unsigned int> _state_dofs_per_block;

      dealii::ConstraintMatrix _control_hanging_node_constraints;
      dealii::ConstraintMatrix _state_hanging_node_constraints;

      const dealii::SmartPointer<const FE> _control_fe;
      const dealii::SmartPointer<const FE> _state_fe;
      //
      //      const dealii::SmartPointer<const DOpEWrapper::FECollection<dealdim> >
      //          _control_fe_collection;
      //      const dealii::SmartPointer<const DOpEWrapper::FECollection<dealdim> >
      //          _state_fe_collection;

      std::vector<Point<dealdim> > _support_points;

      Constraints _constraints;
      dealii::SolutionTransfer<dealdim, VECTOR>* _control_mesh_transfer;
      bool  _sparse_mkr_dynamic,_constr_mkr_dynamic;
   };

  /**************************explicit instantiation*************/

  /**
   * Implementation of virtual function in SpaceTimeHandler
   */
  template<>
    void
    DOpE::MethodOfLines_SpaceTimeHandler<
        DOpEWrapper::FiniteElement<deal_II_dimension>,
        dealii::DoFHandler<deal_II_dimension>,
        dealii::BlockSparsityPattern,
        dealii::BlockVector<double>,
        SparsityMaker<dealii::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        ConstraintsMaker<dealii::DoFHandler<deal_II_dimension>,
            deal_II_dimension> , dope_dimension, deal_II_dimension>::ComputeControlSparsityPattern(
        dealii::BlockSparsityPattern & sparsity) const
    {
      const std::vector<unsigned int>& blocks = this->GetControlDoFsPerBlock();
      dealii::BlockCompressedSimpleSparsityPattern csp(blocks.size(),
          blocks.size());
      for (unsigned int i = 0; i < blocks.size(); i++)
        {
          for (unsigned int j = 0; j < blocks.size(); j++)
            {
              csp.block(i, j).reinit(this->GetControlDoFsPerBlock(i),
                  this->GetControlDoFsPerBlock(j));
            }
        }
      csp.collect_sizes();
#if dope_dimension > 0
      //We use here dealii::DoFHandler<dealdim>, because if dope_dim >0 then dopedim = dealdim.
      dealii::DoFTools::make_sparsity_pattern (static_cast<const dealii::DoFHandler<deal_II_dimension>&>(this->GetControlDoFHandler()),csp);
#else
      abort();
#endif
      this->GetControlHangingNodeConstraints().condense(csp);
      sparsity.copy_from(csp);
    }

  /******************************************************/

  template<>
    void
    MethodOfLines_SpaceTimeHandler<
        DOpEWrapper::FiniteElement<deal_II_dimension>,
        dealii::DoFHandler<deal_II_dimension>,
        dealii::SparsityPattern,
        dealii::Vector<double>,
        SparsityMaker<dealii::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        ConstraintsMaker<dealii::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        dope_dimension,
        deal_II_dimension>::ComputeControlSparsityPattern(
        dealii::SparsityPattern & sparsity) const
    {
      const unsigned int total_dofs = this->GetControlNDoFs();
      dealii::CompressedSimpleSparsityPattern csp(total_dofs, total_dofs);

#if dope_dimension > 0
      dealii::DoFTools::make_sparsity_pattern (static_cast<const dealii::DoFHandler<deal_II_dimension>&>(this->GetControlDoFHandler()),csp);
#else
      abort();
#endif
      this->GetControlHangingNodeConstraints().condense(csp);
      sparsity.copy_from(csp);
    }

  /**
   * Implementation of virtual function in SpaceTimeHandler
   */
  template<>
    void
    DOpE::MethodOfLines_SpaceTimeHandler<
    DOpEWrapper::FECollection<deal_II_dimension>,
    dealii::hp::DoFHandler<deal_II_dimension>,
        dealii::BlockSparsityPattern,
        dealii::BlockVector<double>,
        SparsityMaker<dealii::hp::DoFHandler<deal_II_dimension>,deal_II_dimension>,
        ConstraintsMaker<dealii::hp::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        dope_dimension,
        deal_II_dimension>::ComputeControlSparsityPattern(
        dealii::BlockSparsityPattern & sparsity) const
    {
      const std::vector<unsigned int>& blocks = this->GetControlDoFsPerBlock();
      dealii::BlockCompressedSimpleSparsityPattern csp(blocks.size(),
          blocks.size());
      for (unsigned int i = 0; i < blocks.size(); i++)
        {
          for (unsigned int j = 0; j < blocks.size(); j++)
            {
              csp.block(i, j).reinit(this->GetControlDoFsPerBlock(i),
                  this->GetControlDoFsPerBlock(j));
            }
        }
      csp.collect_sizes();
#if dope_dimension > 0
      //We use here dealii::DoFHandler<dealdim>, because if dope_dim >0 then dopedim = dealdim.
      dealii::DoFTools::make_sparsity_pattern (static_cast<const dealii::hp::DoFHandler<deal_II_dimension>&>(this->GetControlDoFHandler()),csp);
#else
      abort();
#endif
      this->GetControlHangingNodeConstraints().condense(csp);
      sparsity.copy_from(csp);
    }

  /******************************************************/

  template<>
    void
    MethodOfLines_SpaceTimeHandler<
        DOpEWrapper::FECollection<deal_II_dimension>,
        dealii::hp::DoFHandler<deal_II_dimension>,
        dealii::SparsityPattern,
        dealii::Vector<double>,
        SparsityMaker<dealii::hp::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        ConstraintsMaker<dealii::hp::DoFHandler<deal_II_dimension>, deal_II_dimension> ,
        dope_dimension, deal_II_dimension>::ComputeControlSparsityPattern(
        dealii::SparsityPattern & sparsity) const
    {
      const unsigned int total_dofs = this->GetControlNDoFs();
      dealii::CompressedSimpleSparsityPattern csp(total_dofs, total_dofs);

#if dope_dimension > 0
      dealii::DoFTools::make_sparsity_pattern (static_cast<const dealii::hp::DoFHandler<deal_II_dimension>&>(this->GetControlDoFHandler()),csp);
#else
      abort();
#endif
      this->GetControlHangingNodeConstraints().condense(csp);
      sparsity.copy_from(csp);
    }

}

#endif
