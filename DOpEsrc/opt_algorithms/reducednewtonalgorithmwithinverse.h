/**
*
* Copyright (C) 2012-2014 by the DOpElib authors
*
* This file is part of DOpElib
*
* DOpElib is free software: you can redistribute it
* and/or modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation, either
* version 3 of the License, or (at your option) any later
* version.
*
* DOpElib is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
* PURPOSE.  See the GNU General Public License for more
* details.
*
* Please refer to the file LICENSE.TXT included in this distribution
* for further information on this license.
*
**/

#ifndef REDUCEDNEWTON__ALGORITHM_INVERSE_H_
#define REDUCEDNEWTON__ALGORITHM_INVERSE_H_

#include <opt_algorithms/reducednewtonalgorithm.h>
#include <include/parameterreader.h>

#include <iostream>
#include <assert.h>
#include <iomanip>
namespace DOpE
{
  /**
   * This class provides a solver for equality constrained optimization
   * problems in reduced form, i.e., the dependent variable is
   * assumed to be eliminated by solving the equation. I.e.,
   * we solve the problem min j(q)
   *
   * This class implements a linesearch newton algorithm where the linear system is solved
   * exactly. This requires that <PROBLEM> posseses a working method
   * PROBLEM::ComputeReducedHessianInverseVector which is reasonable only if the problem
   * has a very simple structure.
   *
   * @tparam <PROBLEM>     The problem to deal with.
   * @tparam <VECTOR>      The type of Vector used in the ControlVectors
   */
  template <typename PROBLEM, typename VECTOR>
  class ReducedNewtonAlgorithmWithInverse : public ReducedNewtonAlgorithm<PROBLEM, VECTOR>
  {
  public:
    /**
     * The constructor for the algorithm
     *
     * @param OP              A pointer to the problem container
     * @param S               The reduced problem. This object handles the equality
     *                        constraint. For the interface see ReducedProblemInterface.
     * @param param_reader    A parameter reader to access user given runtime parameters.
     * @param Except          The DOpEExceptionHandler. This is used to handle the output
     *                        by all exception.
     * @param Output          The DOpEOutputHandler. This takes care of all output
     *                        generated by the problem.
     * @param base_priority   An offset for the priority of the output generated by the algorithm.
     */
    ReducedNewtonAlgorithmWithInverse(PROBLEM *OP,
                                      ReducedProblemInterface<PROBLEM, VECTOR> *S,
                                      ParameterReader &param_reader,
                                      DOpEExceptionHandler<VECTOR> *Except=NULL,
                                      DOpEOutputHandler<VECTOR> *Output=NULL,
                                      int base_priority=0);
    ~ReducedNewtonAlgorithmWithInverse();

    /**
     * Used to declare run time parameters. This is needed to declare all
     * parameters a startup without the need for an object to be already
     * declared.
     */
    static void declare_params(ParameterReader &param_reader);


    /**
     * This solves an Optimizationproblem in only the control variable
     * by a newtons method.
     *
     * @param q           The initial point.
     * @param global_tol  An optional parameter specifying the required  tolerance.
     *                    The actual tolerance is the maximum of this and the one specified in the param
     *                    file. Its default value is negative, so that it has no influence if not specified.
     */
    virtual int Solve(ControlVector<VECTOR> &q,double global_tol=-1.);

  protected:
    /**
     * Solves the linear system corresponding to the unconstrained quadratic
     * model \min_p j(q) + j'(q)p + 1/2 p^TH(q)p
     *
     * The values for j'(q) need to be provided. Here it is assumed that the
     * hessian can be inverted directly!
     *
     * @param q      The fixed point where j, j' is evaluated and H needs to be calculated.
     * @param gradient              The l^2 gradient of the costfunctional at q,
     *                              i.e., the gradient_i = \delta_{q_i} j(q)
     *                              where q_i denotes the i-th DoF for the control.
     * @param gradient_transposed   The transposed of the gradient. This is assumed
     *                              to be such that if q lives in a Hilbert space Q, then
     *                              (gradient_transposed,gradient)_{l^2} = \|j'(q)\|_Q^2
     * @param dq                    The solution of the model minimization, i.e.,
     *                              H(q)dq = - j'(q).
     */
    int SolveReducedLinearSystem(const ControlVector<VECTOR> &q,
                                 const ControlVector<VECTOR> &gradient,
                                 const ControlVector<VECTOR> &gradient_transposed,
                                 ControlVector<VECTOR> &dq);

    double Residual(const ControlVector<VECTOR> &gradient,
                    const ControlVector<VECTOR> & /*gradient_transposed*/)
    {
      return  gradient*gradient;
    }
  private:
    unsigned int line_maxiter_;
    double       linesearch_rho_, linesearch_c_;

  };

  /***************************************************************************************/
  /****************************************IMPLEMENTATION*********************************/
  /***************************************************************************************/
  using namespace dealii;

  /******************************************************/

  template <typename PROBLEM, typename VECTOR>
  void ReducedNewtonAlgorithmWithInverse<PROBLEM, VECTOR>::declare_params(ParameterReader &param_reader)
  {
    ReducedNewtonAlgorithm<PROBLEM, VECTOR>::declare_params(param_reader);
  }
  /******************************************************/

  template <typename PROBLEM, typename VECTOR>
  ReducedNewtonAlgorithmWithInverse<PROBLEM, VECTOR>
  ::ReducedNewtonAlgorithmWithInverse(PROBLEM *OP,
                                      ReducedProblemInterface<PROBLEM, VECTOR> *S,
                                      ParameterReader &param_reader,
                                      DOpEExceptionHandler<VECTOR> *Except,
                                      DOpEOutputHandler<VECTOR> *Output,
                                      int base_priority)
    : ReducedNewtonAlgorithm<PROBLEM, VECTOR>(OP,S,param_reader,Except,Output,base_priority)
  {
    param_reader.SetSubsection("reducednewtonalgorithm parameters");
    line_maxiter_         = param_reader.get_integer ("line_maxiter");
    linesearch_rho_       = param_reader.get_double ("linesearch_rho");
    linesearch_c_         = param_reader.get_double ("linesearch_c");
  }

  /******************************************************/

  template <typename PROBLEM, typename VECTOR>
  ReducedNewtonAlgorithmWithInverse<PROBLEM, VECTOR>::~ReducedNewtonAlgorithmWithInverse()
  {

  }
  /******************************************************/

  template <typename PROBLEM, typename VECTOR>
  int ReducedNewtonAlgorithmWithInverse<PROBLEM, VECTOR>::Solve(ControlVector<VECTOR> &q,double global_tol)
  {
    return ReducedNewtonAlgorithm<PROBLEM, VECTOR>::Solve(q,global_tol);
  }

  /******************************************************/

  template <typename PROBLEM, typename VECTOR>
  int ReducedNewtonAlgorithmWithInverse<PROBLEM, VECTOR>
  ::SolveReducedLinearSystem(const ControlVector<VECTOR> &q,
                             const ControlVector<VECTOR> &gradient,
                             const ControlVector<VECTOR> & /*gradient_transposed*/,
                             ControlVector<VECTOR> &dq)
  {
    int iter = 0;
    this->GetReducedProblem()->ComputeReducedHessianInverseVector(q,gradient,dq);
//  {
//    //Check...
//    ControlVector<VECTOR> Hd(q), Hd_transposed(q);
//    this->GetReducedProblem()->ComputeReducedHessianVector(q,dq,Hd,Hd_transposed);
//    Hd.add(-1.,gradient);
//    std::cout<<" Linear residual "<<Hd*Hd<<std::endl;
//  }
    return iter;
  }


  /******************************************************/
}
#endif
