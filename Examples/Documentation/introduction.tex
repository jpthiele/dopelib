\chapter{Introduction}\label{chap:intro}
\section{License information}
{\bf TODO:} Unter welcher License soll DOpE laufen?

\section{Developers}
The library is currently maintained by 
\begin{itemize}
  \item Christian Goll (Heidelberg University)
  \item Thomas Wick (Heidelberg University)
  \item Winnifried Wollner (University of Hamburg)
\end{itemize}

However, there are more highly appreciated contributions
made by %(in alphabetical order)
\begin{itemize}
  \item Michael Geiger (Examples for Plasticity, and Documentation of several PDE-Examples)
\end{itemize}

\section{Software requirements}
The library DOpE has been tested to work on both Linux and 
MAC OSX. See also the \texttt{README.OSX} file 

\texttt{DOpElib} requires a recent \texttt{g++} (at least 4.4.3) due to 
some new \texttt{C++} features implemented in \texttt{C++0x} and \texttt{C++11}. 

\subsection{deal.II}
This library is based upon \texttt{deal.II} hence in order to run 
\texttt{DOpElib} you need a running copy of \texttt{deal.II}.

The \texttt{deal.II} library is open source and is freely available for noncommercial project.
It can be downloaded from \url{http://www.dealii.org/}. On this
homepage, one also finds lots of further information on deal.II as well as
an extensive tutorial where many features of deal.II are discussed in a
well-documented example framework. In order to use DOpE, it is highly
recommendable to be roughly acquainted with deal.II.

When installing \texttt{deal.II} you should take care to configure 
it to use UMFPACK, i.e.,\\
\texttt{./configure --with-umfpack}

\subsection{ThirdPartyLibraries}
In order for \texttt{DOpE} to be able to auto-detect some of the installed 
Third Party Libraries you should generate according links in the 
\texttt{ThirdPartyLibs}. See also \texttt{ThirdPartyLibs/README}.

\subsubsection{SNOPT}
If you would like to use the features offered in our SNOPT wrapper. You will 
need to obtain a license for \texttt{SNOPT} 
\url{http://www.sbsi-sol-optimize.com/asp/sol_product_snopt.htm}.
Unfortunately this is at present not available for free, but you should 
check if 
there is a department license already available.
For further information you should consult the file 
\texttt{ThirdPartyLibs/SNOPT.INSTALLNOTES}. In particular you need to configure 
\texttt{deal.II} with at least the following options:\\
\texttt{./configure --with-umfpack --with-blas --with-lapack}

\section{Installation}
I) Get a copy of \texttt{DOpElib} from the svn repository using\\
\texttt{svn co --username=[your username] \textbackslash \\ \hspace*{5mm}https://ganymed.iwr.uni-heidelberg.de/svn/dope}\\
(The backslash in the first line means that the line will be continued as one!)
Note that you need a valid username and password. If you have none you can contact the 
maintainer by sending an EMail to \url{dope@ganymed.iwr.uni-heidelberg.de}.\\[3mm]
%
II) Install \texttt{deal.II} to your home directory, i.e., it should be located in \\
\texttt{\textasciitilde/deal.II}. \\[1mm]
If you would like to have another path you will either have to manually edit the files
\texttt{DOpEsrc/source/Makefile} and \texttt{Examples/Make.global\underline{ }options} and replace the 
line \\
\texttt{D = \$(HOME)/deal.II} with the appropriate path.\\[1mm]
Configure it properly and make the whole \texttt{deal.II} library.\\[3mm]
%
III) If you want to use some of the supported third party libraries install them and follow 
 the instructions in \texttt{ThirdPartyLibs/README}. There may be further information 
 in some \texttt{ThirdPartyLibs/*.INSTALLNOTES} that you may want to consider.\\[3mm]
%
IV) To build the \texttt{DOpElib} you have to change to the directory 
\texttt{DOpEsrc} where you can call\\ 
\texttt{make all}\\
to build the library. If you want to generate some documentation you may use
\texttt{make pdf-doc} or \texttt{make html-doc} which will require either 
latex or doxygen to be installed on your computer.\\[3mm]
%
V) To build the Examples change to the \texttt{Examples} directory and \texttt{make all}.
%
VI) Finally you may wish to test if everything worked. To do so you can 
change to the \texttt{Examples} directory and \texttt{make tests} which will give you a 
list of all the examples and whether they behave as expected by the library, see also 
Chapter~\ref{chap:test}.

\section{How this library is structured}
This library is designed to allow easy implementation and numerical solutions 
of problems involving partial differential equations (PDEs). The easiest case 
is that of a PDE in weak form to find some $u$
\[
a(u)(\phi) = 0 \quad \forall \phi \in V,
\]
with some appropriate space $V$.
More complex cases involve optimization problems given in the form (OPT)
\begin{align*}
\min\;&J(q,u) \\
  &\text{s.t.}\; a(q,u)(\phi) = 0 \quad \forall \phi\in V,\\
  &a \le q \le b,\\
  &g(q,u) \le 0,  
\end{align*}
where $u$ is a FE-function and $q$ can either be a FE-function or some 
fixed number of parameters, $a$ and $b$ are constraint bounds for the control $q$,
and $g(\cdot)$ is some state constraint.


\subsection{Problem description}
In order to allow our algorithms the automatic assembly of all required 
data we need to have some container which contains the complete problem 
description in a common data format. For this we have the following 
classes in \texttt{DOpEsrc/container}
\begin{itemize}
  \item \texttt{pdeproblemcontainer.h} Is used to describe  stationary PDE problems.
  \item \texttt{instatpdeproblemcontainer.h} {\bf TODO is still missing but will be used for nonstationary problems.} This will be implemented once we have nonstationary optimization problems running to avoid error duplication in the coding process.
  \item \texttt{optproblem.h} Is used to describe  OPT problems governed by 
    stationary PDEs. {\bf TODO should be renamed to optproblemcontainer.h including the class name!}
  \item \texttt{instatoptproblemcontainer.h} Is used to describe  OPT problems governed by nonstationary PDEs. The only difference to the stationary case is that we need to specify a time-stepping method.  
\end{itemize}
In order to fill these containers there are two things to be done,
first we need to actually write some data, for instance,
the semilinear form $a(\cdot)(\cdot)$, a target functional $J(\cdot)$, etc.,
which describe the problem. Then we have to select some numerical 
algorithm components like finite elements, linear solvers $\ldots$.
The latter ones should be written such that when exchanging these components
none of the problem descriptions should require changes. 
Note that it still may be necessary to write some additional descriptions, 
e.g., if you solve the PDE with a fix point iteration you don't need derivatives
but if you want to use Newton's method, derivatives are needed.

We will start by discussing the problem description components implemented so far


\subsection{Numeric components}
These are the components from which a user needs to select some in order to actually 
solve the given problem. They will not require any rewriting, but sometimes it is 
advisable to write other than the default parameter into the param file for the 
solution.

\subsubsection{Space-time handler}
First we need to select a method how to handle all dofs in space and time.
\begin{itemize}
\item \texttt{basic/spacetimehandler\underline{ }base.h} This class is used to define 
  an interface to the dimension independent functionality of all space time dof handlers.
  {\bf TODO: Beispiele geben}
\item \texttt{basic/statespacetimehandler.h} Another intermediate interface class which adds 
  the dimension dependent functionality if only the variable $u$ is considered, i.e., a 
  PDE problem.
\item \texttt{basic/spacetimehandler.h } Same as above but with both $q$ and $u$, i.e., for
  OPT problems.
\item \texttt{basic/mol\underline{ }statespacetimehandler.h} Implementation of a method of 
  line space time dof handler for PDE problems. It has only one spatial 
  dofhandler that is used for all time intervals.
\item \texttt{basic/mol\underline{ }spacetimehandler.h} Same as above for OPT problems.
  A separate spatial dof handler for each of the variables $q$ and $u$ is maintained 
  but only one triangulation.
\item \texttt{basic/mol\underline{ }multimesh\underline{ }spacetimehandler.h}
  Same as above, but now in addition the triangulations for $q$ and $u$ can be refined
  separately from one common initial coarse triangulation. Note that this will
  in addition require the use of the multimesh version for integrator and 
  face- as well as celldatacontainer.
\end{itemize}
Note that we use these for stationary problems as well, but then you don't have to specify
any time information.

\subsubsection{Container classes}
Second you will need to specify some container classes to be used to 
pass data between objects. At present you don't have much choice, but you may wish 
to reimplement some of these if you need data that is not currently included in 
the containers.
\begin{itemize}
\item \texttt{container/celldatacontainer.h} This object is used to pass data 
  given on the current element (cell) of the mesh to the functions in PDE, functional, 
  $\ldots$. 
\item \texttt{container/facedatacontainer.h} This object is used to pass data 
  given on the current face of the mesh to the functions in PDE, functional, 
  $\ldots$. 
\item \texttt{container/multimesh\underline{ }celldatacontainer.h} This is the same as the 
  celldatacontainer, but it
  is capable to handle data defined on an alternative triangulation.
\item \texttt{container/multimesh\underline{ }facedatacontainer.h} This is the same as the
  facedatacontainer, but it
  is capable to handle data defined on an alternative triangulation.
\item \texttt{container/integratordatacontainer.h} This contains some data that 
  should be passed to the integrator like quadrature formulas and the above cell and 
  face data container.
\end{itemize}

\subsubsection{Time stepping schemes}
Third, at least for nonstationary PDEs we need to select a time stepping scheme
the file names of which are mostly self explanatory:
\begin{itemize}
\item \texttt{include/forward\underline{ }euler\underline{ }problem.h}
\item \texttt{include/shifted\underline{ }crank\underline{ }nicolson\underline{ }problem.h}
\item \texttt{include/backward\underline{ }euler\underline{ }problem.h}
\item \texttt{include/fractional\underline{ }step\underline{ }theta\underline{ }problem.h} Note that the use of this scheme requires a special Newton solver, which is, however, already
implemented for the convenience of the user!
\item \texttt{include/crank\underline{ }nicolson\underline{ }problem.h}
\end{itemize}

\subsubsection{Integrator routines}
Finally, we need to select a way how to integrate and solve linear and nonlinear equations
\begin{itemize}
\item \texttt{templates/integrator.h} This class computes integrals over a given 
  triangulation (including its faces).
\item \texttt{templates/integrator\underline{ }multimesh.h} The same as above but it is 
  possible that some of the FE functions are defined on an other triangulation 
  as long as the have a common coarse triangulation.
\item \texttt{templates/integratormixeddims.h} This is used to compute integral which 
  are given in another (larger) dimension than the current variable. (This is exclusively
  used if the control variable is given by some parameters. Which means \texttt{dopedim == 0}). 
\end{itemize}

\subsubsection{Nonlinear solvers}
\begin{itemize}
\item \texttt{templates/newtonsolver.h} This solves some nonlinear equation using a 
  line-search Newton method.
\item \texttt{templates/newtonsolvermixeddims.h} The same but in the case when there is 
  another variable in a (larger) dimension is involved. See 
  \texttt{integratormixeddims.h}.
\item \texttt{templates/instat\underline{ }step\underline{ }newtonsolver.h} This is a 
  Newton method as above to invert the next time-step. It differs from the plain vanilla
  version in that it computes certain data from the previous time step only once 
  and not in every Newton iteration.
\item \texttt{templates/fractional\underline{ }step\underline{ }theta\underline{ }step\underline{ }newtonsolver.h} This is the Newton solver for the time step in a 
  fractional-step-theta scheme. It combines the computation of all three sub steps.
\end{itemize}

\subsubsection{Linear solvers}
\begin{itemize}
\item \texttt{templates/cglinearsolver.h} This is a wrapper for the cg solver implemented in 
  \texttt{deal.II}. The solver will build and store the stiffness matrix for the PDE.
\item \texttt{templates/gmreslinearsolver.h} This is a wrapper for the gmres solver 
  implemented in \texttt{deal.II}. The solver will build and store the stiffness matrix 
  for the PDE.
\item \texttt{templates/directlinearsolver.h} This is a wrapper for the direct solver 
  implemented in \texttt{deal.II} using \texttt{UMFPACK}. 
  The solver will build and store the stiffness matrix for the PDE.
\item \texttt{templates/voidlinearsolver.h} This is a wrapper for certain cases when we 
  know that the matrix to be inverted is the identity. It simply copies the rhs to the
  lhs. This is only needed for compatibility reasons some other components.
\end{itemize}



\subsection{Problem specific classes}
The following classes are used to describe the problem and will usually require 
some implementation.

\begin{itemize}
  \item \texttt{basic/constraints.h} This is used by the spacetimehandlers to 
    compute the number of constraints from the control and state vectors. 
    It must not be reimplemented by the user, but needs to be properly 
    initialized if OPT is used with box control constraints or $g(q,u) \le 0$.
  \item \texttt{interfaces/functionalinterface.h} This gives an interface 
    for the functional $J(\cdot)$ and any other functional you may want to evaluate.
    In general this can be used as a base class to write your own functionals 
    in examples. We note that we only need to write the integrands on 
    elements or faces the loop over elements will be taken care of in the integrator.
    Specifically, derivatives are written therein, too.
  \item \texttt{interfaces/constraintinterface.h} This gives an interface for both 
    the control box constraints as well as the general constraint $g \le 0$. This 
    needs to be specified if constraints are to be used. If they are not needed 
    a default class \texttt{problemdata/noconstraints.h} can be used. We note that we only 
    need to write the integrands on 
    elements or faces the loop over elements will be taken care of in the integrator.
  \item \texttt{interfaces/pdeinterface.h} This defines an interface for the 
    partial differential equation $a(q,u)(\phi) = 0$. This needs to be written
    by the user. We note that we only need to write the integrands on 
    elements or faces the loop over elements will be taken care of in the integrator.
    Specifically, derivatives are written therein, too.
  \item \texttt{interfaces/dirichletdatainterface.h} This gives an interface to the 
    Dirichlet data for a problem. If the Dirichlet data are simply a function 
    (and do not depend on the control $q$) one can use the default class\\
    \texttt{problemdata/simpledirichletdata.h}.
\end{itemize}




\subsection{Reduced problems (Solve the PDE)}
At times it is nice to remove the PDE constraint in (OPT). 
This is handled by so called reduced 
problems (for algorithmic aspects we refer the reader to 
\cite{BeMeVe06}). 
This means that the reduced problem implicitly solves the PDE whenever required
and eliminates the variable $u$ from the problem.
\begin{itemize}
\item \texttt{reducedproblems/statpdeproblem.h} This is used to remove the variable $u$ in 
  a stationary PDE problem. This means that call the method \\
  \texttt{StatPDEProblem::ComputeReducedFunctionals} will evaluate the functionals 
  defined in the problem description, i.e., in \texttt{PDEProblemContainer}, in the 
  solution of the given PDE.
\item \texttt{reducedproblems/statreducedproblem.h} This eliminates $u$ from the OPT
  problem with a stationary PDE.
\item \texttt{reducedproblems/instatreducedproblem.h} The same as above but for a
  nonstationary PDE. {\bf FIXME there is something wrong in this file see FIXME 
    comment in the source.}
\item \texttt{reducedproblems/voidreducedproblem.h} A wrapper file that eliminates $u$ 
  if it is not present anyways. This is used so that we can use the same routines to 
  solve problems that have no PDE constraint.
\end{itemize}

\subsection{Optimization algorithms}
Now, in order to solve optimization algorithms we need to define some algorithms.
At present we offer a selection of algorithms that solve the reduced optimization 
problem where the PDE constraint has been eliminated as explained in the previous section.
\begin{itemize}
\item \texttt{opt\underline{ }algorithms/reducedalgorithm.h} An interface for all 
  optimization problems in the reduced formulation. It offers some test functionality
  to assert that the derivatives of the problem are computed correctly.
\item \texttt{opt\underline{ }algorithms/reducednewtonalgorithm.h}
  A line-search Newton algorithm using a cg method to invert the reduced hessian. 
  Implementation ignores any additional constraints.
\item \texttt{opt\underline{ }algorithms/reducedtrustregionnewton.h}
  A trust region Newton algorithm using a cg method to invert the reduced hessian.
  Implementation ignores any additional constraints.
\item \texttt{opt\underline{ }algorithms/reduced\underline{ }snopt\underline{ }algorithm.h}
  An algorithm to solve reduced optimization problems with additional control constraints.
  ((reduced) state constraints are not yet implemented.)
\item \texttt{opt\underline{ }algorithms/reducednewtonalgorithmwithinverse.h}
  Line-search Newton algorithm that assumes there exists a method in the reduced problem
  that can invert the reduced hessian. (This usually makes sense only if there is no 
  PDE constraint.)
\item \texttt{opt\underline{ }algorithms/generalized\underline{ }mma\underline{ }algorithm.h}
  An implementation of the MMA-Algorithm for structural optimization using an augmented
  Lagrangian formulation for the subproblems. The subproblem is implemented using the 
  special purpose file
  \texttt{include/augmentedlagrangianproblem.h}.
\end{itemize} 

\subsection{Other Components}
Beyond these clearly structured groups before there are some classes remaining that
do not fit the above but are important for the user to know.

\subsubsection{Vectors}
\begin{itemize}
\item \texttt{include/statevector.h} This stores all dofs in space and time for the state 
  variable $u$. It is possible to select whether all this should be kept in memory or 
  or unused parts can be written to the hard disk.
\item \texttt{include/controlvector.h} This stores all dofs in space and time for the 
  control variable $q$. At present no time dependence is implemented.
\item \texttt{include/constraintvector.h} This stores all dofs in space and time for the 
  non PDE constraints (and corresponding multipliers). 
  At present no time dependence is implemented.
\end{itemize}

\subsubsection{Parameter handling}
\begin{itemize}
\item \texttt{include/parameterreader.h} This file is used to define a parameter reader
  that is used to read run time parameters from a given file.
\end{itemize}

\subsubsection{Exception handling}
\begin{itemize}
\item \texttt{include/dopeexception.h} Defines some Exceptions that are thrown by the program
  should it encounter any unexpected errors.
\item \texttt{include/dopeexceptionhandler.h} This class is used to write information 
  contained in the exceptions to the output in a uniform manner.
\end{itemize}

\subsubsection{Output handling}
\begin{itemize}
\item \texttt{include/outputhandler.h} This file defines an outputhandler object which 
  can be used to decide whether some information should be written to screen or file.
  In addition it can format output according to some run time parameters given by a 
  parameter file.
\end{itemize}

\subsection{Data Access}
\begin{itemize}
\item \texttt{include/solutionextractor.h} This class is used to gain access to the finite element 
  solutions stored in the reduced problems.
\end{itemize}

\subsubsection{Constraints and system matrix}
\begin{itemize}
\item \texttt{include/userdefineddofconstraints.h} This class sets the constraints on the DOFs of the state and/or control FE solution. DOpE itself builds the hanging-node-constraints, but the user can reimplement this class and thus include other constraints as well (for example periodic BC). Note, that the hanging-node-constraints come first (in case of conflicting constraints.)
\item \texttt{include/sparsitymaker.h} This class sets the sparsity pattern for the state FE solution. The standard implementation is just a wrapper for \texttt{dealii::DoFTools::} \texttt{make\_sparsity\_pattern}, but the user can reimplement this class to allow for more sophisticated sparsity patterns.
\end{itemize}

\subsubsection{HP components}
\begin{itemize}
\item \texttt{interfaces/active\underline{ }fe\underline{ }index\underline{ }setter\underline{ }interface.h} In the case of hp finite elements, one has to specify for each cell which finite element to use. This is done via this interface.
\end{itemize}

\subsection{Internal structures}
{\bf TODO: ab hier habe ich noch nichts gemacht (TW)}
\subsubsection{Interface Classes}
\begin{itemize}
  \item \texttt{interfaces/transposeddirichletdatainterface.h} This provides an interface to 
    the functionality required by {\em transposed Dirichlet data}. Usually when one applies Dirichlet 
    data $g$ to a function one has to calculate a continuation $Bg$ which is defined on the whole domain.
    In optimization problems when the Dirichlet data depends on the control one has to evaluate the 
    dual operator $B^*$ in order to obtain a representation for the reduced gradient of the objective $J$.
    This is done using the {\em transposed Dirichlet data}.
  \item \texttt{interfaces/reducedprobleminterface.h} In order to allow all algorithms to be written independent
    of the given (OPT) problem 
    (and not requiring the problem as template argument) there is a common base class which 
    defines the required interfaces. 
  \item \texttt{interfaces/pdeprobleminterface.h} The same as above but for (PDE) problems.
\end{itemize}

\subsubsection{Default Classes}
\begin{itemize}
  \item \texttt{problemdata/noconstraints.h} A class that can be used for optimization problems 
    having only a PDE constraint but no further constraints.
  \item \texttt{problemdata/simpledirichletdata.h} A class that can be used to implement Dirichlet
    data that are given as a fixed function (independent of the control).
  \end{itemize}

\subsubsection{Auto-generated Problem Descriptions}
\begin{itemize}
  \item \texttt{problemdata/stateproblem.h} This is the problem description for the (forward/primal) PDE constraint.
    {\bf Similar descriptors will be build for the other problems (adjoint, tangent, $\ldots$) when time allows.}
  \item \texttt{problemdata/initialproblem.h} This is the problem descriptor to compute the finite element representation
    of the initial values. This is generated by the different time-stepping schemes based upon the defined 
    representation by the pde, which is set to the component wise $L^2$ projection by default.
  \item \texttt{problemdata/primaldirichletdata.h} This class contains the Dirichlet data for the 
    forward/primal PDE.
  \item \texttt{problemdata/tangentdirichletdata.h} This class contains the Dirichlet data for the tangent PDE, i.e.,
    the first derivative of the Dirichlet data.
  \item \texttt{problemdata/transposedgradientdirichletdata.h} This contains the transposed Dirichlet data needed 
    to calculate the gradient of the reduced objective functional, 
    for detail see \texttt{interfaces/transposeddirichletdatainterface.h}.
  \item \texttt{problemdata/transposedhessiandirichletdata.h} This contains the transposed Dirichlet data needed 
    to calculate the hessian of the reduced objective functional, 
    for detail see \texttt{interfaces/transposeddirichletdatainterface.h}.
\end{itemize}
\subsubsection{Management of Time Dependent Problems}
\begin{itemize}
\item \texttt{include/timedofhandler.h} DoFHandler responsible for the management of the timedofs (this is a part of the \texttt{SpaceTimeDoFHandler}-classes). Basically a wrapper for a $1d$ \texttt{deal.II}-DoFHandler.
\item \texttt{include/timeiterator.h} This class works as an iterator on the \texttt{TimeDoFHandler}.                 
\end{itemize}
\subsection{Wrapper classes}
\begin{itemize}
  \item \texttt{wrapper/dofhandler\underline{ }wrapper.h} A wrapper class for the \texttt{deal.II} DoFHandlers. This 
    class is needed to provide support for the \texttt{dim $= 0$} case and to have a uniform interface to 
    DoFHandler and HPDoFHandler.
  \item \texttt{wrapper/preconditioner\underline{ }wrapper.h} Contains wrappers for several of the preconditioners
    in \texttt{deal.II}. This is required since unfortunately the preconditioners in \texttt{deal.II} have different
    interfaces for their initialization.
  \item \texttt{wrapper/function\underline{ }wrapper.h} An interface that allows to use functions that depend 
    not only on space but also on time.
  \item \texttt{wrapper/snopt\underline{ }wrapper.h} An interface to the SNOPT fortran library. This is an additional
    wrapper to the one provided by SNOPT to allow automatic construction of the functions required 
    by SNOPT using our library.
  \item \texttt{wrapper/fevalues\underline{ }wrapper.h} {\bf Will be removed soon!}
\end{itemize}

\subsection{Other}
\begin{itemize}
  \item \texttt{basic/dopetypes.h} This file contains type definitions used in the library. 
\end{itemize}

{\bf TODO! The following files need some appropriate description here 
This should be done by someone who knows what they are used for. Please move the description to the right place above.} tsschemes.

\marginpar{TODO}

basic:
      sth\underline{ }internals.h                     

include:   
            helper.h                                          


  


