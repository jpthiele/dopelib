\chapter{Foreword}
In this report, we describe the DOpE
\textit{Deal Optimization Environment} project. 
Originally, the project was initiated in the year 2009 at the 
University of Heidelberg (Germany) in the numerical analysis
group of Rolf Rannacher. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \textit{Deal Optimization Environment} (DOpE) project is 
based on the \textit{deal.II} finite element library which has been developed
 initially by W. Bangerth, R. Hartmann, and G. Kanschat. \marginpar{Citation}
Its main feature is to give a unified interface to highlevel algorithms such as 
time stepping methods, nonlinear solvers and optimization routines. 
We aim that the user should only need to write those parts
of the code that are problem dependent while all invariant parts of the algorithms
should be reusable without any need for further coding.
In particular, the user should be able to switch between various different 
algorithms without the need to rewrite the problem dependent code, though he or she will
have to replace the algorithm object with an other one. 

The authors acknwoledge their past experience as well as discussions with 
the authors of the libraries 
Gascoigne/RoDoBo project, which was initiated by 
Roland Becker, Dominik Meidner,  and Boris Vexler. \marginpar{Citation} 
From which some of the ideas to modularize the algorithms have arisen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The aim of DOpE is to provide a software toolkit to solve forward PDE
problems as well as optimal control problems constrained by PDE. The
solution of a broad variety of PDE is possible in deal.II as well, but
DOpE concentrates on a unified approach for both linear and nonlinear
problems by interpreting every PDE problem as nonlinear and applying a
Newton method to solve it. While deal.II leaves much of the work and many
decisions to the user, DOpE intends to be user-optimized by delivering
prefabricated tools which require from the user only adjustments connected
to his specific problem. The solution of optimal control problems with PDE
constraints is an innovation in the DOpE framework.
The focus is on the numerical solution of both stationary and nonstationary
problems which come from different application fields, like elasticity and
plasticity, fluid dynamics, and fluid-structure interactions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
At the present stage the following features are supported by the library
\begin{itemize}
\item Solution of stationary and nonstationary PDEs in 1d, 2d, and 3d.
\item Various timestepping schemes (based on finite differences), 
  such as forward Euler, backward Euler,
  Crank-Nicolson, shifted Crank-Nicolson, and Fractional-Step-$\Theta$ scheme.
\item All finite elements of from deal.ii including hp-support.
\item Several examples showing the solution of several PDEs including
   Poisson, Navier-Stokes, Plasticity and fluid-structure interaction problems. 
\item Self written linesearch and trustregion newton algorithms for the 
   solution of optimization problems with PDEs. (cp. Nocedal \& Wright\marginpar{Citation})
\item Interface to SNOPT for the solution of optimization problems with PDEs and
  additional other constraints.
\item Several examples showing how to solve various kinds of optimization problems
  involving stationary PDE constraints.
\item Mesh adaptation.
\item Different spatial triangulations for control and state variables.
\end{itemize}
 
The rest of this document is structured as follows: We start with an introduction in
Chapter~\ref{chap:intro} where you will learn what is needed to run {\tt DOpElib}. 
Further you will learn what problems we can solve and how all the different classes 
work together for this purpose. This should help you figure out what the different classes
do if you are in need of writing your own algorithm.

Then assuming that you can work to your satisfaction with the algorithms already implemented
we will show you how to create your own running example in Chapter~\ref{chap:howtoex}.
This will be followed by a detailed description of all examples already shipped with 
the library. You can find the examples for the solution of PDEs in Chaper~\ref{PDE}
and those for the solution of optimization problems with PDEs in Chapter~\ref{OPT}.

These notes conclude with a section that explains how we do automated testing of the 
implementation in Chapter~\ref{chap:test}. This chapter will be of interest only if you 
are trying to implement some new features to the library so that you can check that 
the new code did not break anything.

